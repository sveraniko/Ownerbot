# AGENTS.md — агентный процесс разработки SIS (Codex + Qoder)

> Цель документа: **сделать работу с LLM предсказуемой**, не ломая то, что уже работает, и не превращая каждую правку в археологическую экспедицию.

---

## 0) Термины

- **SIS** — Telegram‑коммерция/контент‑платформа: каталог товаров/луков, корзина/заказы, доступ (Levels), staged payments (deposit/preorder/partial), авто‑nudge, контент‑библиотека в заказах, продление доступа, course mode для луков.
- **Baseline** — *единственная* схема БД для “холодного старта” проекта. Любые новые таблицы/поля **добавляются в baseline**.
- **LLM‑агенты**:
  - **Codex** — “Builder”: реализует PR по ТЗ/промпту.
  - **Qoder** — “Auditor/Fixer”: быстро находит баги/несостыковки, чинит точечно, валидирует гипотезы, ускоряет разбор.

---

## 1) Главная идея: два агента, один процесс

### 1.1 Роли

**Codex (Builder)**
- Пишет код, добавляет тесты, правит baseline.
- Делает **только то**, что описано в PR‑промпте.
- Не “улучшает архитектуру” по настроению.

**Qoder (Auditor/Fixer)**
- Делает ревью после Codex, ловит регрессии, чинит локально.
- Если видит “архитектурный дефект” — сначала предлагает **минимальный фикс**, и только если он невозможен, эскалирует на дизайн‑PR.

**Human (Owner/Architect)** — ты
- Принимаешь решения по продукту, инвариантам, UX и приоритетам.
- Утверждаешь стратегию: что делаем сейчас, что потом, что никогда.

### 1.2 Правило “Builder не мыслит, Auditor не пишет фичи”

- Codex **не спорит с ТЗ**, а реализует.
- Qoder **не придумывает новые фичи**, а проверяет/чинит.

---

## 2) Структура репозитория (ориентир)

- `app/bot/*` — Telegram UI/handlers/routers
- `app/domain/*` — бизнес‑логика, сервисы, модели (domain DTO)
- `app/infrastructure/*` — ORM модели, baseline, storage, внешние интеграции
- `app/analytics/*` — события/каталог/эмиттер
- `tests/*` и `app/tests/*` — unit + базовые проверки cold‑start/parity
- `scripts/*` — dev‑утилиты (reset db и т.п.)

---

## 3) “Политики проекта” (SSOT)

Этот файл — только про агентный процесс. Полные политики будут в отдельных документах:

- `PROJECT_BASE.md` — “что такое SIS”, какие модули есть, какие инварианты
- `BASELINE_POLICY.md` — как живём со схемой (baseline‑only, без новых ревизий)
- `UI_STATE_POLICY.md` — правила UI‑сообщений/cleanup/якорных панелей
- `ACCESS_MODEL.md` — глобальный gate + target‑policies + TargetGuard
- `PR_STACK.md` — дорожная карта PR‑ов (feature stack)

---

## 4) Золотые правила, без которых всё развалится

### 4.1 Additive‑only по умолчанию
- **Не удалять существующий функционал**.
- Не менять семантику существующих флоу, если PR не про это.
- Любое “удалил, потому что лишнее” = потенциальный регресс.

### 4.2 “Один источник истины” (SSOT) для расчётов/решений
- Если уже есть канонический helper (например, `compute_due_snapshot(...)`), **никаких локальных расчётов рядом**.

### 4.3 Baseline‑first
- Новые поля/таблицы **обязаны** появиться в baseline (`0001_baseline.py` или эквивалент).
- В тестах, где `metadata.create_all(...)` используется с явным списком таблиц — список **обновить**.

### 4.4 Минимальный дифф
- Любая правка должна быть локализована.
- Массовые “cleanup везде”, “рефактор всего FSM” — только отдельным дизайн‑PR, и только после доказательства необходимости.

### 4.5 Детерминированный UX
- Бот должен вести себя предсказуемо: если кнопка “Каталог” = Home, то она остаётся Home и не превращается в “иногда Home”.

---

## 5) Что Codex обязан делать перед кодингом

**Шаг 0. Прочитать базу проекта**
- Обязательно: `PROJECT_BASE.md`, `BASELINE_POLICY.md`, `UI_STATE_POLICY.md`, `ACCESS_MODEL.md`
- По задаче доступа/контента/депозитов: дополнительно читать релевантный раздел в `PR_STACK.md`

**Шаг 1. Скан (быстрый, без “дай я перепишу всё”)**
- `rg -n "<ключевые сущности>" app/ tests/`
- Найти SSOT‑функции/сервисы
- Определить 3–6 файлов, которые реально надо менять

**Шаг 2. План в 10–20 строк**
- Что меняем
- Где
- Какие инварианты нельзя ломать
- Какие тесты добавить/обновить

Только после этого — кодинг.

---

## 6) Формат “идеального PR‑промпта для Codex”

Каждый PR‑промпт должен содержать:

1. **Motivation (зачем)** — 3–7 пунктов
2. **Non‑Goals (чего не делаем)** — обязателен!
3. **Invariants (что нельзя сломать)** — списком
4. **Scope / Files** — какие папки/модули трогаем
5. **Implementation steps** — пошагово, без двусмысленностей
6. **Baseline impact** — какие таблицы/поля добавляются, где именно в baseline
7. **Tests** — какие тесты создать/поправить; “минимальный набор”
8. **Acceptance criteria** — как руками проверить

---

## 7) Когда звать Qoder и что ему поручать

Qoder эффективен для:
- “Почему оно падает после рестарта?”
- “Где хранится state и кто его чистит?”
- “Какая функция реально SSOT?”
- “Сопоставь план с текущим кодом”
- “Сделай аудит baseline: появились новые поля?”

**Плохо поручать Qoder:**
- “Перепиши всю архитектуру UI cleanup”
- “Сделай глобальный рефактор FSM”
- “Заменим подход на новый фреймворк”

---

## 8) Библиотека типовых задач (готовые шаблоны)

### 8.1 QODER‑CHECK (аудит/сопоставление)

**Шаблон:**
- Найди точки входа (handlers/routers)
- Найди доменный SSOT (service/helper)
- Найди storage слой (ORM/baseline/tests)
- Выдай:
  - root cause (1–2 абзаца)
  - минимальный фикс (локально)
  - риски/альтернативы (если минимальный фикс невозможен)

### 8.2 CODEX‑BUILD (реализация PR)

**Шаблон:**
- Реализуй только описанные изменения
- Не трогай не‑скоуп файлы
- Добавь targeted tests
- Обнови baseline
- Сводка: “что изменено, где, почему”

---

## 9) Критические зоны SIS (не трогать без отдельного PR)

### 9.1 Access / Levels
- Глобальный gate (business‑wide) и target‑policies существуют параллельно.
- UI‑рендер locked‑screen должен быть единым (через TargetGuard).

### 9.2 Deposits / Staged payments
- Суммы “к оплате сейчас” должны считаться строго SSOT helper‑ом.
- Autonudge и Pay‑For‑Me должны использовать те же расчёты.

### 9.3 UI cleanup / Anchor panels
- Любые изменения message cleanup должны быть **точечными**, иначе быстро ломаются reply‑клавиатуры и якорные панели.
- Если для какой‑то подсистемы уже реализован паттерн устойчивого хранения message_id (например, support‑thread в Redis), он может быть образцом, но переносить его надо **отдельным PR**.

---

## 10) “Запреты” для Codex (жёстко)

Codex **НЕ ИМЕЕТ ПРАВА** без явного указания в PR‑промпте:

- Удалять/переписывать существующие модули “потому что так красивее”
- Делать массовый рефакторинг по проекту
- Менять протоколы callback_data (сломает старые сообщения)
- Менять ключевые UX‑паттерны (reply keyboard, home‑flow)
- Добавлять новые Alembic ревизии (в этом проекте baseline‑only)
- Вносить “оптимизации” в бизнес‑логику оплат/доступов без тестов на консистентность

---

## 11) Мини‑чеклист перед merge

- [ ] baseline обновлён (если есть schema изменения)
- [ ] tests зелёные (минимум по PR + smoke критичных модулей)
- [ ] нет изменений callback_data без причины
- [ ] нет “переезда” файлов/папок без причины
- [ ] есть short manual checklist (как проверить руками)

---

## 12) Соглашения по неймингу PR и коммитов

- PR: `PR-<AREA>-<NN>: <кратко>`
  - примеры: `PR-DEPOSIT-02`, `PR-CONTENT-RENEW-01`, `PR-UI-CATALOG-PANELS-01`
- Коммит: тот же префикс, без “misc”.

---

## 13) Важное: этот документ не заменяет базу проекта

AGENTS.md описывает **как работать с агентами**.
Он не должен превращаться в “всё обо всём”.

Следующий документ, который создаётся после AGENTS.md:
- `PROJECT_BASE.md` — единая база проекта (SSOT по смыслу/архитектуре).

